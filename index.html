<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Excel Search Tool â€” Enhanced (Contacts &amp; Matching Line)</title>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f4f4f4; }
    .container { max-width: 980px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    input[type="file"], select, button, input[type="text"] {
      display: block; width: 100%; margin-bottom: 12px; padding: 10px; border-radius: 4px; border: 1px solid #ccc;
      box-sizing: border-box;
    }
    label { font-weight: bold; margin-bottom: 5px; display: block; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .dropdown-checkboxes { position: relative; margin-bottom: 12px; }
    .checkbox-menu {
      position: absolute; background: white; border: 1px solid #ccc;
      max-height: 200px; overflow-y: auto; z-index: 1000; display: none; width: 100%;
    }
    .checkbox-menu label {
      display: block; padding: 8px; cursor: pointer; user-select: none;
    }
    .checkbox-menu input[type="checkbox"] { margin-right: 10px; accent-color: #000; }
    .dropdown-checkboxes.active .checkbox-menu { display: block; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    td, th { border: 1px solid #ccc; padding: 10px; background: #fff; text-align: left; }
    th { background: #eee; }
    .highlight { background-color: yellow; font-weight: bold; }
    .hidden { display: none; }
    .download-buttons { display: flex; gap: 10px; margin-top: 15px; }
    .download-buttons button { flex: 1; }
    .note { font-size: 12px; color: #666; margin-top: -6px; margin-bottom: 10px; }
    .optline { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
  </style>
</head>
<body>
<div class="container">
<h2>Excel Search Tool â€” Enhanced</h2>
<input accept=".xlsx,.xls,.xlsm" id="fileInput" type="file"/>
<div class="row">
<div>
<label for="searchMode">Search mode:</label>
<select id="searchMode">
<option selected="" value="1">1 keyword</option>
<option value="2">2 keywords</option>
<option value="3">3 keywords</option>
<option value="4">Exact phrase</option>
</select>
</div>
<div>
<label for="searchColumn">Column to search (from file):</label>
<select id="searchColumn"></select>
</div>
</div>
<div id="keywordInputs"></div>
<div class="hidden" id="sequentialToggleContainer" style="margin-bottom: 12px;">
<label><input id="sequentialToggle" type="checkbox"/> Match keywords in sequence (Keyword 1 â†’ Keyword 2 â†’ Keyword 3)</label>
</div>
<label>Columns to include in output (from file):</label>
<div class="dropdown-checkboxes" id="outputColumnDropdown">
<input onclick="toggleCheckboxMenu()" placeholder="Select output columns" readonly="" type="text"/>
<div class="checkbox-menu" id="checkboxMenu"></div>
</div>
<div class="optline">
<label><input checked="" id="keepOnlyMatchingLine" type="checkbox"/> Keep only the matching line (not full message)</label>
<label><input checked="" id="appendContact" type="checkbox"/> Append contact label + unique phone numbers to Content</label>
<label><input checked="" id="createNumbersCol" type="checkbox"/> Copy phone numbers to new column <b>ContactNumbers</b></label>
<label><input checked="" id="dedupeRows" type="checkbox"/> Drop duplicate rows</label>
<label><input checked="" id="dedupeNumbers" type="checkbox"/> De-dup numbers per line</label>
</div>
<div class="note">These options implement your criteria without changing existing behaviors unless boxes are checked.</div>
<button onclick="processFile()">Search</button>
<div class="download-buttons hidden" id="downloadSection">
<button onclick="downloadHTML()">Download HTML</button>
<button onclick="downloadExcel()">Download Excel</button>
</div>
<div id="resultCount"></div>
<table id="resultTable"></table>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.16.9/xlsx.full.min.js"></script>
<script>
    let workbookData = [], headers = [], results = [], outputCols = [], searchColIdx = 0, searchKeywords = [];
    let dateColIndices = [];

    const keywordInputsDiv = document.getElementById("keywordInputs");
    const searchModeSelect = document.getElementById("searchMode");
    searchModeSelect.addEventListener("change", renderKeywordInputs);
    renderKeywordInputs();

    function renderKeywordInputs() {
      const mode = parseInt(searchModeSelect.value);
      keywordInputsDiv.innerHTML = "";
      const label = (mode === 4) ? "Enter exact phrase:" : "Enter keyword #";
      const count = (mode === 4) ? 1 : mode;
      for (let i = 1; i <= count; i++) {
        const input = document.createElement("input");
        input.type = "text";
        input.placeholder = (mode === 4) ? label : `${label} ${i}`;
        input.className = "keyword";
        keywordInputsDiv.appendChild(input);
      }
      document.getElementById("sequentialToggleContainer").classList.toggle("hidden", !(mode === 2 || mode === 3));
    }

    function toggleCheckboxMenu() {
      document.getElementById("outputColumnDropdown").classList.toggle("active");
    }

    document.addEventListener("click", function(e) {
      if (!document.getElementById("outputColumnDropdown").contains(e.target)) {
        document.getElementById("outputColumnDropdown").classList.remove("active");
      }
    });

    document.getElementById("fileInput").addEventListener("change", function() {
      const file = this.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
        workbookData = rows;
        headers = rows[0];
        identifyDateColumns();
        populateSearchDropdown();
        populateOutputCheckboxes();
      };
      reader.readAsArrayBuffer(file);
    });

    function identifyDateColumns() {
      dateColIndices = [];
      headers.forEach((header, idx) => {
        if (typeof header === "string" && header.toLowerCase().includes("date")) {
          dateColIndices.push(idx);
        }
      });
    }

    function populateSearchDropdown() {
      const select = document.getElementById("searchColumn");
      select.innerHTML = "";
      headers.forEach((header, idx) => {
        const opt = document.createElement("option");
        opt.value = idx;
        opt.textContent = header;
        select.appendChild(opt);
      if (header.toLowerCase() === 'content') { select.value = idx; }
      });
    }

    function populateOutputCheckboxes() {
      const menu = document.getElementById("checkboxMenu");
      menu.innerHTML = "";
      headers.forEach((header, idx) => {
        const label = document.createElement("label");
        label.innerHTML = `<input type="checkbox" value="${idx}" ${header.toLowerCase() === "content" ? "checked" : ""}/> ${header}`;
        menu.appendChild(label);
      });
      // Also add ContactNumbers (virtual) column checkbox
      const label = document.createElement("label");
      label.innerHTML = `<input type="checkbox" value="-1" checked/> ContactNumbers`;
      menu.appendChild(label);

      updateOutputPlaceholder();
      menu.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.addEventListener('change', updateOutputPlaceholder));
    }

    function updateOutputPlaceholder() {
      const selected = Array.from(document.querySelectorAll("#checkboxMenu input:checked")).map(cb => {
        const idx = parseInt(cb.value);
        return (idx === -1) ? "ContactNumbers" : headers[idx];
      });
      document.querySelector("#outputColumnDropdown input").value = selected.join(", ");
    }

    function formatDate(excelDate) {
      const date = XLSX.SSF.parse_date_code(excelDate);
      if (!date) return excelDate;
      const d = new Date(Date.UTC(date.y, date.m - 1, date.d));
      return `${("0" + d.getDate()).slice(-2)}-${("0" + (d.getMonth() + 1)).slice(-2)}-${d.getFullYear().toString().slice(-2)}`;
    }

    // --- Contact extraction helpers ---
    function uniqueInOrder(arr) {
      const seen = new Set();
      const out = [];
      arr.forEach(x => {
        const k = String(x).trim().toLowerCase();
        if (k && !seen.has(k)) { seen.add(k); out.push(String(x).trim()); }
      });
      return out;
    }

    function extractNumbers(text) {
      if (!text) return [];
      const raw = String(text).match(/\+?\d[\d\-\s]{8,}\d/g) || [];
      const seen = new Set();
      const nums = [];
      raw.forEach(r => {
        const norm = r.replace(/\D/g, "");
        if (norm.length >= 10 && !seen.has(norm)) { seen.add(norm); nums.push(norm); }
      });
      return nums;
    }

    function extractLabels(text) {
      if (!text) return [];
      const t = String(text);
      const labels = [];
      // Contact:
      const m = t.match(/Contact[:\s\-\*]*([^\d\nðŸ“ž]{1,80})/i);
      if (m) labels.push(m[1].trim());
      // *Starred* names
      (t.match(/\*+([A-Za-z][A-Za-z\s\.\-&]+?)\*+/g) || []).forEach(s => {
        const inner = s.replace(/^\*+|\*+$/g, "");
        labels.push(inner.trim());
      });
      // Words before phone emoji
      (t.match(/([A-Za-z][A-Za-z\s\.\-&]{1,40})ðŸ“ž/g) || []).forEach(s => {
        labels.push(s.replace("ðŸ“ž","").trim());
      });
      // Regards/Thanks Name
      (t.match(/(?:Regards|Thanks)[\s,:-]*([A-Za-z][A-Za-z\s\.\-&]{1,40})/gi) || []).forEach(s => {
        const mm = s.match(/(?:Regards|Thanks)[\s,:-]*([A-Za-z][A-Za-z\s\.\-&]{1,40})/i);
        if (mm) labels.push(mm[1].trim());
      });
      // Filter out obvious project phrases
      const filtered = labels.filter(lbl => !/\b(brisk|lumbini|dlf|phase|green meadows|plot|plots)\b/i.test(lbl));
      return uniqueInOrder(filtered);
    }

    function findMatchingLines(cellValue, lowerKeywords, mode, sequential) {
      const lines = String(cellValue).split(/\r?\n/);
      return lines.filter(line => {
        const lc = line.toLowerCase();
        if (mode === 4) return lc.includes(lowerKeywords[0]);
        if ((mode === 2 || mode === 3) && sequential) {
          if (!lc.includes(lowerKeywords[0])) return false;
          return lowerKeywords.slice(1).every(k => lc.includes(k));
        }
        return lowerKeywords.every(k => lc.includes(k));
      });
    }

    function processFile() {
      const mode = parseInt(searchModeSelect.value);
      const sequential = document.getElementById("sequentialToggle").checked;
      const keepOnlyMatchingLine = document.getElementById("keepOnlyMatchingLine").checked;
      const appendContact = document.getElementById("appendContact").checked;
      const createNumbersCol = document.getElementById("createNumbersCol").checked;
      const dedupeRows = document.getElementById("dedupeRows").checked;
      const dedupeNumbers = document.getElementById("dedupeNumbers").checked;

      const inputs = document.querySelectorAll(".keyword");
      const keywords = Array.from(inputs).map(i => i.value.trim()).filter(k => k);
      if ((mode < 4 && keywords.length !== mode) || (mode === 4 && keywords.length !== 1)) {
        alert("Please enter the correct number of keywords/phrase.");
        return;
      }
      searchColIdx = parseInt(document.getElementById("searchColumn").value);
      outputCols = Array.from(document.querySelectorAll("#checkboxMenu input:checked")).map(cb => parseInt(cb.value));
      if (isNaN(searchColIdx) || outputCols.length === 0) {
        alert("Please select a search column and at least one output column.");
        return;
      }

      const lowerKeywords = keywords.map(k => k.toLowerCase());
      const seen = new Set();
      results = [];
      searchKeywords = keywords;

      for (let i = 1; i < workbookData.length; i++) {
        const row = workbookData[i];
        if (!row) continue;
        const cell = row[searchColIdx];
        if (!cell) continue;

        const lowerCell = String(cell).toLowerCase();
        let match = false;
        if (mode === 4) {
          match = lowerCell.includes(lowerKeywords[0]);
        } else if ((mode === 2 || mode === 3) && sequential) {
          if (!lowerCell.includes(lowerKeywords[0])) {
            match = false;
          } else {
            match = lowerKeywords.slice(1).every(k => lowerCell.includes(k));
          }
        } else {
          match = lowerKeywords.every(k => lowerCell.includes(k));
        }

        if (!match) continue;

        // Decide which "content" to show: only matching line or full cell
        let contentForOutput;
        if (keepOnlyMatchingLine) {
          const lines = findMatchingLines(cell, lowerKeywords, mode, sequential);
          // If multiple lines match, we will create a separate output row for each
          if (lines.length === 0) continue;
          const labels = appendContact ? extractLabels(String(row[searchColIdx])) : [];
          const numbersAll = extractNumbers(String(row[searchColIdx]));
          const numbers = dedupeNumbers ? uniqueInOrder(numbersAll) : numbersAll;

          lines.forEach(singleLine => {
            let finalLine = String(singleLine);
            // Do not delete/alter text in the matching line itself; only append (if requested)
            if (appendContact) {
              const digitsInLine = new Set((finalLine.match(/\d{10,}/g) || []));
              const numsToAppend = numbers.filter(n => !digitsInLine.has(n));
              const tailPieces = [];
              if (labels.length) tailPieces.push(labels.join(" "));
              if (numsToAppend.length) tailPieces.push(numsToAppend.join(" "));
              const tail = tailPieces.length ? (" " + tailPieces.join(" ")) : "";
              finalLine = (finalLine + tail).trim();
            }

            // Build result row mapped to selected output columns (plus virtual ContactNumbers)
            const resultRow = outputCols.map(idx => {
              if (idx === -1) {
                // virtual ContactNumbers column from final content
                return (createNumbersCol ? uniqueInOrder(extractNumbers(finalLine)).join(", ") : "");
              }
              let val = row[idx];
              // Date formatting
              if (dateColIndices.includes(idx) && typeof val === "number" && XLSX.SSF.parse_date_code(val)) {
                val = formatDate(val);
              }
              // If this is the searched column and we're keeping only matching line, replace with finalLine
              if (idx === searchColIdx) {
                let strVal = finalLine;
                // highlight keywords in the (possibly appended) line
                lowerKeywords.forEach(k => {
                  const regex = new RegExp(k, "gi");
                  strVal = strVal.replace(regex, m => `<span class="highlight">${m}</span>`);
                });
                return strVal;
              }
              return (val == null ? "" : val);
            });

            // De-dupe by the visible "Content" column (or searched column) text
            const dedupeKey = String(resultRow[outputCols.indexOf(searchColIdx)] || "").toLowerCase().replace(/\s+/g, " ").trim()
                               + "|CN:" + (createNumbersCol ? String(resultRow[outputCols.indexOf(-1)] || "") : "");
            if (!dedupeRows || !seen.has(dedupeKey)) {
              if (dedupeRows) seen.add(dedupeKey);
              results.push(resultRow);
            }
          });

        } else {
          // keep full cell (original behavior), but still optionally append contact and numbers to searched column
          let strVal = String(cell);
          if (appendContact) {
            const labels = extractLabels(strVal);
            const numbersAll = extractNumbers(strVal);
            const numbers = dedupeNumbers ? uniqueInOrder(numbersAll) : numbersAll;
            const digitsInLine = new Set((strVal.match(/\d{10,}/g) || []));
            const numsToAppend = numbers.filter(n => !digitsInLine.has(n));
            const tailPieces = [];
            if (labels.length) tailPieces.push(labels.join(" "));
            if (numsToAppend.length) tailPieces.push(numsToAppend.join(" "));
            const tail = tailPieces.length ? (" " + tailPieces.join(" ")) : "";
            strVal = (strVal + tail).trim();
          }

          const resultRow = outputCols.map(idx => {
            if (idx === -1) {
              return (createNumbersCol ? uniqueInOrder(extractNumbers(strVal)).join(", ") : "");
            }
            let val = row[idx];
            if (dateColIndices.includes(idx) && typeof val === "number" && XLSX.SSF.parse_date_code(val)) {
              val = formatDate(val);
            }
            if (idx === searchColIdx) {
              let tmp = strVal;
              const lowerKeywords = keywords.map(k => k.toLowerCase());
              lowerKeywords.forEach(k => {
                const regex = new RegExp(k, "gi");
                tmp = tmp.replace(regex, m => `<span class="highlight">${m}</span>`);
              });
              return tmp;
            }
            return (val == null ? "" : val);
          });

          const dedupeKey = String(resultRow[outputCols.indexOf(searchColIdx)] || "").toLowerCase().replace(/\s+/g, " ").trim()
                             + "|CN:" + (createNumbersCol ? String(resultRow[outputCols.indexOf(-1)] || "") : "");
          if (!dedupeRows || !seen.has(dedupeKey)) {
            if (dedupeRows) seen.add(dedupeKey);
            results.push(resultRow);
          }
        }
      }

      displayResults(results, outputCols);
    }

    function displayResults(results, outputCols) {
      const table = document.getElementById("resultTable");
      const resultCount = document.getElementById("resultCount");
      const downloadSection = document.getElementById("downloadSection");

      if (results.length === 0) {
        resultCount.textContent = "No matches found.";
        table.innerHTML = "";
        downloadSection.classList.add("hidden");
        return;
      }

      resultCount.textContent = `${results.length} match${results.length > 1 ? "es" : ""} found.`;

      let html = "<thead><tr>";
      outputCols.forEach(idx => { html += `<th>${idx === -1 ? "ContactNumbers" : headers[idx]}</th>`; });
      html += "</tr></thead><tbody>";
      results.forEach(row => {
        html += "<tr>" + row.map(cell => `<td>${cell}</td>`).join("") + "</tr>";
      });
      html += "</tbody>";

      table.innerHTML = html;
      downloadSection.classList.remove("hidden");
    }

    function getKeywordFileName(ext) {
      return searchKeywords.join("_").replace(/\s+/g, "_").replace(/[^\w\-]/g, "") + ext;
    }

    function downloadHTML() {
      const tableHTML = document.getElementById("resultTable").outerHTML;
      const htmlContent = `
        <html><head><meta charset="UTF-8"><title>Search Results</title>
        <style>table { border-collapse: collapse; } td, th { border: 1px solid #ccc; padding: 8px; }</style>
        </head><body>${tableHTML}</body></html>
      `;
      const blob = new Blob([htmlContent], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = getKeywordFileName(".html");
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function downloadExcel() {
      const wb = XLSX.utils.book_new();
      const table = document.getElementById("resultTable");
      const ws = XLSX.utils.table_to_sheet(table);
      XLSX.utils.book_append_sheet(wb, ws, "Results");
      XLSX.writeFile(wb, getKeywordFileName(".xlsx"));
    }
  </script>
</body>
</html>
